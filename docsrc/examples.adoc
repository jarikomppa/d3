## Example Snippets

Here's a few example snippets of more complicated behaviors that are possible with flag manipulation.

### Simple Dialogue

The description-choices structure can also describe dialogue with a non-player character.

    $Q start
    Well hello there. What do you want to know about?
    $A name
    Name
    $A jobs
    Jobs
    $A virtue
    Virtue
    
### Button Toggle

    $Q room
    $P !light
    Light is off
    $P light
    Light is on
    $A room toggle:light
    Toggle light

This example has a single room with a light that can be on or off. The player's option always points back to the same room, and the optional text blocks show whether the light is on or off.

The same flag could be used for other things, such as revealing other things to do if the light is on.

### Using Room Flags to Change Flavor Text

image::flavor.png[Flow chart of the flavor example,align="center"] 

    $Q start
    Go to cave or forest?
    $A cave
    Go to cave
    $A forest
    Go to forest
    
    $Q cave
    Well, go on..
    $A end
    Exit cave
    
    $Q forest
    Well, go on..
    $A end
    Exit forest
    
    $Q end
    $P cave clr:cave
    As you exit the cave, you find...
    $P forest clr:forest
    As you exit the forest, you find...
    $P
    ...the end of the example.
    $A start
    Restart

This example shows two different routes to a room, and the room's description reacts to where you came from. Note that the room flags are also cleared when the flavor text is shown, so it won't be shown again, should the player end up back on the same page from some other direction later on.

### Lock and Key

image::lockandkey.png[Flow chart of the lock and key example,align="center"]

    $Q room
    You're in a room with a door.
    $P !key
    There is a key here.
    $P open
    The door is open.

    $A room !key set:key
    Get key
    $A room key !unlocked set:unlocked 
    Unlock door
    $A locked !unlocked !open
    Open door
    $A room unlocked !open set:open
    Open door
    $A end open
    Exit
    
    $Q locked
    The door is locked.
    $A room
    Dang it!
    
    $Q end
    You went through the door.

In this example the player needs to take a key, unlock door, open door, and leave. When the player initially
reaches this page, the view looks like this:

    You're in a room with a door.
    There is a key here.
    ----
    Get key
    Open door

The "open door" option shown here does not actually open the door, but sends the player to a page that just says "The door is locked" with the only option of returning back to the page.

If the "Get key" option is picked, the player is sent back to the same page, but with the "key" flag enabled. Now the page looks like this:

    You're in a room with a door.
    ----
    Unlock door
    Open door

The "Open door" option is still the same "The door is locked" option. Hitting the "Unlock" option again sends the player back to the same page, now with the "unlocked" flag on.

    You're in a room with a door.
    ----
    Open door

Now the "Open door" option does something different (it's a different "Open door", after all); sending the player back to the same page with the "open" flag on.

    You're in a room with a door.
    The door is open.
    ----
    Exit
    
Finally, the player is given the "Exit" option, which sends the player to the end node, where the game ends.

### Separate Gate

image::separategate.png[Flow chart of the separate gate example,align="center"]

    $Q rivercrossing
    River flows north to south. There's signs of people 
    having crossed the river here.
    $P !dam
    The flow is too strong for you to pass.    
    $A forestpath
    Go north
    $A end dam
    Cross the river
    
    $Q forestpath
    You're on a north-south forest path. There's a river
    to the west.
    $A rivercrossing
    Go south
    $A upstream
    
    $Q upstream
    This is as far north as you can go. There's a forest 
    path south, and a river to the west.
    $P !dam
    It seems you could easily roll a big stone to the river,
    $P dam
    Huge rock is blocking the river flow.
    creating a dam.
    $A forestpath
    Go south
    $A upstream set:dam
    Roll that rock.
    
    $Q end
    You crossed the river.
    
This example uses several locations. The player has to travel upstream to
create a dam in order to be able to cross the river.

### Sticky Randoms

In order to keep the result of a random decision, set the result in a flag.

image::stickyrandoms.png[Flow chart of the sticky randoms example,align="center"] 

    $Q coinroom
    $P !toss clr:result
    $P !toss rnd:64 set:result
    $P set:toss
    $P result
    The coin shows heads.
    $P !result
    The coin shows tails.
    
    $A coinroom
    Look again.
    $A coinroom clear:toss
    Toss again.

In pseudocode, the above becomes:

    If "toss" is not set:
        Clear "result"
    If "toss" is not set, AND random is less than 64:
        Set "result"
    Set "toss"
    If "result" is set
        Print "The coin shows heads."
    If "result" is not set:
        Print "The coin shows tails."

### Nerdy Boolean Logic

Freely ignore this if you don't consider yourself a nerd.

In order to AND two flags, simply check both of them at the same time:

    $O this that
    
In order to OR two flags, check them separately and set a third flag

    $O this set:thisorthat
    $O that set:thisorthat
    $O thisorthat
    
In order to exclusively-or two flags, you can use toggle.

    $O clr:thisxorthat
    $O this toggle:thisxorthat
    $O that toggle:thisxorthat

### Swapping Values

A temporary variable can also be used to swap contents of two numeric variables.

    $A tavern temp=player_money player_money=stranger_money stranger_money=temp
    Swap purses with the stranger

Swapping the state of two flags can also be done through a temporary flag, but can not be done on one line.

    $O clr:t
    $O a set:t clr:a
    $O b set:a clr:b
    $O t set:b
    
## Examples

Here's short overview of some of the examples included in the kit.

### Simple

image::simple.png[Flow chart of the Simple example,align="center"] 

The simple example has four pages, with links between them. None of the more 
advanced features of DialogTree are used.

### Complex

image::complex.png[Flow chart of the Complex example,align="center"] 

The complex example concentrates on the more advanced features of DialogTree, including
flag manipulation, and primarily has one heavily self-referential page.

The player needs to put on a light in order to see a key, which the player must pick up,
unlock a door, open the door, and then leave.

### Traveller

image::traveller.png[Flow chart of the Traveller example,align="center"] 

In the traveller example the player is expected to run after a fleeing creature, which
hops from one room to the next randomly, with a small chance of it staying put.

This effect is created through a relatively complicated logic. Each room consists of the
following kind of structure:

    $P clr:flip clr:stay
    $P rnd:50 set:flip
    $P rnd:20 set:stay
    $P red !stay flip clr:red set:green
    You see Yellow run towards the green room.
    $P red !stay !flip clr:red set:blue
    You see Yellow run towards the blue room.
    $P red
    You see a wild Yellow here.

First, "flip" and "stay" flags are cleared. Next, "flip" is set 50% of the time, and "stay" is set rather rarely.

Then, if the creature is in this room and is not staying, depending on whether flip is on, the creature is moved
from this room to one of the other ones.

If the creature is still in this room after those checks, we announce it.

### Waiting

image::waiting.png[Flow chart of the Waiting example,align="center"] 

This is the complete "Waiting for the Light" gamebook by Kieran Coghlan, consisting of
a hundred locations, flags and numbers, converted to MuCho, the zx spectrum predecessor of DialogTree. 
The MuCho version was done with persmission of the author. 

To understand the structure, let's look at some sub-graphs.

image::waiting_base.png[Flow chart of the Waiting example: base pages,align="center"]

The base structure is as follows: we start, have a couple simple trap choices, then arrive at the hall of lights (page 49), visit some other segments but eventually pick the white light (page 25) which checks if we've gone through all the other segments (via checking the various items), and then presents one of the 16 endings depending on the player choices in the other colored light segments.

image::waiting_green.png[Flow chart of the Waiting example: green pages,align="center"] 

The green segment is relatively simple (in context of this gamebook). Note that the player can die here in a few ways (p30). In the end, the player can either be kill the beast or not (pages 15 and 16).

image::waiting_pink.png[Flow chart of the Waiting example: pink pages,align="center"] 

The pink segment represents a relatively complex dialogue. Basically you get to recommend various options, one being a good one and the rest are less so.

image::waiting_red.png[Flow chart of the Waiting example: red pages,align="center"]

The red segment is again relatively simple, in the end you get to pick whether to be aggressive or not.

image::waiting_yellow.png[Flow chart of the Waiting example: yellow pages,align="center"] 

The yellow segment is super complicated: it's a game show. Not only can you answer right or wrong, or let the opponent answer instead, if you get the answers right, you can either take a point or take a card that has various results. And if either you or your opponent reaches 3 points, you hop to an ending.

This uses a subpage to check (and display) the scores and a couple numeric variables to keep the score.

The dialogtree version is actually more difficult than the paper version because the player keeps track of the variables in the book version; the computer version hides them, so you don't know which result you're getting from your choices until the end.

### Blackjack

image::blackjack.png[Flow chart of the Blackjack example,align="center"] 

The Blackjack example demonstrates some complex handling of numeric variables. The rules are a bit simplified as compared to actual blackjack; there's no actual card deck, and cards are valued from 0 to 10.

After the intro page the player arrives at the start page where they can choose how much to bet. Note that the game makes sure the player never bets more than they have.

Once a non-zero amount is bet, the player can proceed to the ingame page.

The ingame page does sub-page calls to hit and dealerhit, checks for busts, and asks if player wants to hit or stand, if neither player has gone over 21. If one (or both) players have gone over 21, the player is sent to win, bust, or bothbust pages.

In the stand page there are multiple calls to dealerhit, to make sure the dealer has reached 17 or more. Then the results are checked, and the player is sent to win, bust or bothbust pages. Bothbust is used in case of a tie.

In the bothbust page the player gets the bet back, and is sent back to start to bet again. In the bust page the bet is lost, and we check if player has run out of money, and if so, end the game. There's no separate game over page, we simply won't show the option to start over.

In the win page the player gets their money back twice, and we carefully check if the sum goes over maximum. If it does, we show the good ending text and end the game there. There's no separate game over page in this case either.

The hit and dealerhit pages generate 4 random flags, and then produce a value between 0 and 10 to add to either the player's, or the dealer's, score. Since there are 16 options, 3 of the options give 10 points and 4 of the options give 0 (9+4+3=16). (There's no looping in DialogTree (yet, anyway), so we can't just ignore the zero results and randomize again).

And there you have it - something that approximates blackjack in DialogTree.
